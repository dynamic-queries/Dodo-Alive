"""Comparing the torque profiles generated by the controller to follow a specified
trajectory between our MATLAB simulation and a simulation we do on PyBullet. 

The results on MATLAB were generated analytically and the PyBullet simulations 
use the default position controller from Bullet.
"""
import pybullet as p
import time
import math
import pybullet_data
import csv

# Setup simulation
physicsClient = p.connect(p.GUI)

p.setAdditionalSearchPath(pybullet_data.getDataPath())

# Setup environment
p.setGravity(0,0,-10)
planeId = p.loadURDF("plane.urdf")


# Set parameters
startPos = [0, 0, 2.5]
startOrientation = p.getQuaternionFromEuler([0,0,0])

maxForce = 1000 # max motor force

counter = 0 # set counter to visualize sim parameters every k'th iter


# Load objects
robotId = p.loadURDF("urdf_files/dodo_simple.urdf", startPos, startOrientation, useFixedBase=True)

numJoints = p.getNumJoints(robotId)
robotEndEffectorIndex = 2 # link counting starts from 0, base link doesn't count


# Set center of mass frame (loadURDF sets the pos and orientation of link frame)
p.resetBasePositionAndOrientation(robotId, startPos, startOrientation)


# Read in joint trajectories from csv files
q1 = [] 
q2 = [] 
with open('data/q1.csv', newline='') as csvfile:
    reader = csv.reader(csvfile, delimiter='\t')
    for row in reader:
        for element in row: # need two forloops just because of csv file structure
            q1.append(float(element)) # add the numbers to our python list

with open('data/q2.csv', newline='') as csvfile:
    reader = csv.reader(csvfile, delimiter='\t')
    for row in reader:
        for element in row: 
            q2.append(float(element)) 



for idx in range(len(q1)):
    # Step simulation and pause
    p.stepSimulation()
    time.sleep(1/240)

    q_target = [q1[idx], q2[idx]]

    # Set control
    for jointIdx in range(numJoints-1): # go through all joints except final fixed one
        p.setJointMotorControl2(
            bodyIndex=robotId,
            jointIndex=jointIdx,
            controlMode=p.POSITION_CONTROL,
            targetPosition=q_target,
            force=maxForce
        )

    if counter % 250 == 0:
        print(p.getLinkState(robotId, robotEndEffectorIndex)[0])
        counter = 0 # reset counter

    counter += 1
     